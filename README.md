# TearTest

download link is on the right under "releases" ->

press F11 to toggle exclusive fullscreen mode

this program draws a vertical line at your cursor position. the rendering is event based, not continuous. that means instead of drawing frames in a loop as fast as possible (like most games do), it draws a frame for every cursor position update (this might cause problems when using mice with very high polling rates). this guarantees that no additional latency emerges from cycle misalignment

this program serves to demonstrate several things:
* ***SCREEN TEARING*** - despite the code only drawing a single continuous line, quickly flicking the cursor while in exclusive fullscreen mode will cause the line to tear. this happens because monitors update their screen line by line (actually pixel by pixel even), NOT frame by frame. if the frontbuffer (=the place in memory from where the monitor reads the frame data) is updated while the scan line (=the row of pixels the monitor is currently updating) is in the middle of the screen, then the top half of the screen will show the old frame, while the bottom half shows the new frame, resulting in a torn image. (in the case of this particular program you will even see multiple tear lines per refresh cycle)
* ***GLOBAL VSYNC*** - unless running in exclusive fullscreen mode (not to be confused with borderless windows spanning the entire screen), every program is affected by a global double-buffered vertical synchronization (=vsync) which is applied during desktop composition. vsync prevents tearing by only allowing the front buffer to be updated while the scan line is at the edge of the screen (aka the monitor has finished synchronizing the screen with the front buffer from top to bottom, hence "vertical synchronization"). since the deskop compositor uses double buffering (=1 front buffer to present the current frame, and 1 back buffer to draw the next), each frame is 1 screen refresh cycle old by the time it gets presented (=moved to front buffer), as it got drawn based on whatever data was avaiable right after the previous buffer swap, and sat idle in the back buffer until the next buffer swap. the cursor is exempt of this effect, as it is not drawn by the compositor during desktop composition, but by the gpu during presentation (hence called "hardware cursor"), unless the program draws its own cursor (hence called "software cursor") and told the gpu to hide the hardware cursor. the result of this is that the line is 1 refresh cycle behind the hardware cursor during movement
* ***THE HARDWARE CURSOR POSITION IS ONLY UPDATED DURING VBLANK*** - vblank is the time frame between the end of a given refresh cycle and the start of the following one. in this time frame the frame buffers are swapped and the position of the hardware cursor is updated. further mouse movement is ignored until the next vblank. this has the curious effect that while running in exclusive fullscreen, the hardware cursor always matches the position of the line drawn by this program while at the top of the screen (right after vblank), but is a full refresh cycle behind it at the bottom, because the line has since received further position updates, whereas the hardware cursor didnt
